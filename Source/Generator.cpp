/*
	Copyright 2020 Myles Trevino
	Licensed under the Apache License, Version 2.0
	https://www.apache.org/licenses/LICENSE-2.0
*/


#include "Generator.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>
#include <complex>
#include <thread>
#include <glm/gtc/reciprocal.hpp>
#include <glm/gtx/transform.hpp>
#include <fftw/fftw3.h>

#include "Constants.hpp"
#include "Utilities.hpp"
#include "Decoder.hpp"


namespace
{
	float dft_window_duration{30.f}; // Milliseconds.
	float dft_sample_interval{1.f}; // Milliseconds.
	int harmonic_smoothing{15}; // Frequencies.
	int temporal_smoothing{0}; // DFTs.
	float height_multiplier{.33f};
	bool logarithmic{false};

	glm::ivec2 size;
	float height;
	glm::fmat4 center_matrix;

	std::vector<float> audio_data;
	std::vector<std::vector<float>> dft_data;
	float dft_peak;
	LV::Mesh dft_mesh;
	LV::Mesh base_mesh;


	void add_vertex(LV::Mesh* mesh, const glm::fvec3& vertex)
	{ mesh->vertices.emplace_back(center_matrix*glm::fvec4{vertex, 1.f}); }


	void generate_square_indicies(std::vector<unsigned>* indicies, unsigned top_left,
		unsigned bottom_left, unsigned bottom_right, unsigned top_right)
	{
		// Bottom left triangle.
		indicies->emplace_back(top_left);
		indicies->emplace_back(bottom_left);
		indicies->emplace_back(bottom_right);

		// Top right triangle.
		indicies->emplace_back(bottom_right);
		indicies->emplace_back(top_right);
		indicies->emplace_back(top_left);
	}


	void load_audio_data(const std::string& file_name)
	{
		std::cout<<"Loading the audio data...\n";

		// Get the audio data.
		LV::Decoder::load_track_information(file_name);
		LV::Decoder::initialize_resampler_and_decoder();
		LV::Decoder::load_samples();
		audio_data = LV::Decoder::get_data();
		LV::Decoder::destroy();
	}


	float get_hann_multiplier(int x, int maximum)
	{ return .5f*(1.f-std::cos(2.f*3.1415926f*x/(maximum))); }


	std::vector<std::vector<float>> smoothing_iteration(
		std::vector<std::vector<float>>* input, int samples, bool harmonic)
	{
		std::vector<std::vector<float>> result;
		dft_peak = 0.f;

		// For each DFT...
		for(int dft_index{}; dft_index < input->size(); ++dft_index)
		{
			result.emplace_back();

			// For each frequency...
			for(int frequency_index{}; frequency_index <
				(*input)[dft_index].size(); ++frequency_index)
			{
				float decibels{};

				// If no averaging is desired, use the frequency directly,
				if(samples == 0) decibels = (*input)[dft_index][frequency_index];

				// Otherwise, average the surrounding frequencies.
				else
				{
					int divisor{1};

					for(int offset{-samples}; offset <= samples; ++offset)
					{
						// Harmonically sample, applying a Hann window.
						if(harmonic)
						{
							const int sample_index{frequency_index+offset};
							if(sample_index < 0 || sample_index > (*input)[0].size()-1) continue;
							decibels += (*input)[dft_index][sample_index];
						}

						// Temporally sample, applying a Hann window.
						else
						{
							const int sample_index{dft_index+offset};
							if(sample_index < 0 || sample_index > input->size()-1) continue;
							decibels += (*input)[sample_index][frequency_index];
						}

						++divisor;
					}

					decibels /= divisor;
				}

				// Get the peak and emplace back.
				dft_peak = std::max(dft_peak, decibels);
				result.back().emplace_back(decibels);
			}
		}

		input->clear();
		input->shrink_to_fit();
		return result;
	}


	void generate_dft_data()
	{
		// Initialize.
		const int dft_window_size{static_cast<int>(
			LV::Constants::sample_rate*(dft_window_duration/1000.f))};

		const int maximum_frequency{dft_window_size/2-1};

		const int dft_sample_interval_size{static_cast<int>(
			LV::Constants::sample_rate*(dft_sample_interval/1000.f))};

		const size_t generated_dft_count{audio_data.size()/dft_sample_interval_size};

		height = dft_window_size/2.f*height_multiplier;

		// Validate.
		if(dft_window_size > audio_data.size()) throw std::runtime_error{"The DFT window "
			"duration is greater than the duration of the loaded audio file. Decrease the "
			"DFT window duration or load a longer audio file."};

		if(dft_sample_interval_size+dft_window_size > audio_data.size())
			throw std::runtime_error{"The DFT sample interval will result in less than 2 "
			"generated DFTs. Decrease the DFT sample interval or load a longer audio file."};

		if(harmonic_smoothing > maximum_frequency) throw std::runtime_error{"The harmonic "
			"smoothing value will be greater than the number of frequencies generated by the "
			"set DFT window duration. Decrease the harmonic smoothing value or increase the "
			"DFT window duration."};

		if(temporal_smoothing > generated_dft_count) throw std::runtime_error{"The temporal "
			"smoothing value will be greater than the number of generated DFTs. Decrease the "
			"temporal smoothing value or the DFT sample interval, or load a longer audio "
			"file."};

		// Warnings.
		const size_t generated_point_count{generated_dft_count*maximum_frequency};

		if(generated_dft_count*maximum_frequency > 10000000) std::cout<<"WARNING: "+
			std::to_string(generated_point_count)+" data points will be generated with this "
			"configuration. This may cause performance issues. You may want to increase the "
			"DFT sample interval, decrease the DFT window size, or load a shorter audio "
			"file.\n";

		const size_t sampled_point_count{generated_point_count*
			(harmonic_smoothing+temporal_smoothing)*2};

		if(sampled_point_count > 1000000000) std::cout<<"WARNING: "+std::to_string(
			sampled_point_count)+" data points will be sampled with this configuration. This "
			"may cause performance issues. You may want to decrease the harmonic or temporal "
			"smoothing, increase the DFT sample interval, decrease the DFT window size, or "
			"load a shorter audio file.\n";

		// Run a fast Fourier transform.
		std::cout<<"Generating the DFT data...\n";
		fftwf_init_threads();

		std::vector<float> input(dft_window_size);
		std::vector<std::complex<float>> output(dft_window_size);

		fftwf_plan_with_nthreads(std::thread::hardware_concurrency());
		fftwf_plan plan{fftwf_plan_dft_r2c_1d(dft_window_size, input.data(),
			reinterpret_cast<fftwf_complex*>(output.data()), FFTW_MEASURE)};

		uint64_t offset{};
		std::vector<std::vector<float>> raw_dft_data;

		while(offset+dft_window_size < audio_data.size())
		{
			// Fill the input buffer, applying a Hann window.
			for(int index{}; index < dft_window_size; ++index)
			{
				const float hann_multiplier{get_hann_multiplier(index, dft_window_size)};
				input[index] = hann_multiplier*audio_data[offset+index];
			}

			// Execute the fast Fourier transform.
			fftwf_execute(plan);

			raw_dft_data.emplace_back();
			for(int index{}; index < maximum_frequency; ++index)
			{
				// Convert the complex DFT data to decibels.
				std::complex<float> complex_value{output[index]};

				const float magnitude{std::sqrtf(std::powf(complex_value.real(), 2)+
					std::powf(complex_value.imag(), 2))};

				float decibels{20.f*std::log10(magnitude)};
				decibels += LV::Constants::dft_noise_floor;
				if(decibels < 0) decibels = 0;

				// Save the data.
				raw_dft_data.back().emplace_back(decibels);
			}

			offset += dft_sample_interval_size;
		}

		// Apply harmonic smoothing.
		std::vector<std::vector<float>> harmonically_smoothed_dft_data{
			smoothing_iteration(&raw_dft_data, harmonic_smoothing, true)};

		// Apply temporal smoothing.
		dft_data = smoothing_iteration(&harmonically_smoothed_dft_data,
			temporal_smoothing, false);

		size = {dft_data[0].size(), dft_data.size()};

		// Apply normalization and height scaling.
		for(int dft_index{}; dft_index < dft_data.size(); ++dft_index)
			for(int frequency_index{}; frequency_index <
				dft_data[dft_index].size(); ++frequency_index)
			{
				float* value{&dft_data[dft_index][frequency_index]};
				*value = std::min(std::max(*value/dft_peak, 0.f), 1.f)*height;
			}

		// Destroy.
		fftwf_destroy_plan(plan);
		fftwf_cleanup_threads();
	}


	void generate_dft_mesh()
	{
		std::cout<<"Generating the DFT mesh...\n";
		dft_mesh.vertices.clear();
		dft_mesh.indices.clear();

		// For each DFT...
		for(int z{}; z < size.y; ++z)
		{
			// For each value in the DFT...
			float previous_vertex_x{};
			for(int x{}; x < size.x; ++x)
			{
				// Generate the vertex.
				if(logarithmic)
				{
					float normalized_x{x/static_cast<float>(size.x)};
					float log_x{std::clamp(-std::logf(normalized_x), .1f, 3.f)};
					float vertex_x{previous_vertex_x+log_x};
					add_vertex(&dft_mesh, glm::fvec3{vertex_x, dft_data[z][x], z});
					previous_vertex_x = vertex_x;
				}

				else add_vertex(&dft_mesh, glm::fvec3{x, dft_data[z][x], z});

				// Generate the indices.
				if(z >= size.y-1 || x >= size.x-1) continue;

				const unsigned top_left{static_cast<unsigned>(z*size.x+x)};
				const unsigned	bottom_left{static_cast<unsigned>(top_left+size.x)};
				const unsigned	bottom_right{bottom_left+1};
				const unsigned	top_right{top_left+1};

				generate_square_indicies(&dft_mesh.indices,
					top_left, bottom_left, bottom_right, top_right);
			}
		}
	}


	void generate_side_mesh(bool iterate_x, bool extreme)
	{
		const int max{iterate_x ? size.x : size.y};
		const int static_value{extreme ? iterate_x ? size.y-1 : size.x-1 : 0};
		int z{static_value}, x{static_value};

		for(int index{}; index < max; ++index)
		{
			if(iterate_x) x = index; else z = index;

			// Generate the verticies (top and bottom).
			add_vertex(&base_mesh, glm::fvec3{x, dft_data[z][x], z});
			add_vertex(&base_mesh, glm::fvec3{x, LV::Constants::bottom, z});

			// Generate the indicies.
			if(index >= max-1) continue;

			const unsigned base_index{static_cast<unsigned>(base_mesh.vertices.size()-2)};
			const bool couterclockwise{iterate_x ? extreme : !extreme};

			if(couterclockwise) generate_square_indicies(&base_mesh.indices,
				base_index, base_index+1, base_index+3, base_index+2);

			else generate_square_indicies(&base_mesh.indices,
				base_index+2, base_index+3, base_index+1, base_index);
		}
	}


	void generate_bottom_mesh()
	{
		const unsigned base_index{static_cast<unsigned>(base_mesh.vertices.size())};

		// Generate the vertices (top-left, bottom-left, bottom-right, top-right).
		add_vertex(&base_mesh, glm::fvec3{0.f, LV::Constants::bottom, size.y-1});
		add_vertex(&base_mesh, glm::fvec3{size.x-1, LV::Constants::bottom, size.y-1});
		add_vertex(&base_mesh, glm::fvec3{0.f, LV::Constants::bottom, 0.f});
		add_vertex(&base_mesh, glm::fvec3{size.x-1, LV::Constants::bottom, 0.f});

		// Generate the indicies.
		generate_square_indicies(&base_mesh.indices,
			base_index, base_index+2, base_index+3, base_index+1);
	}


	void generate_base_mesh()
	{
		base_mesh.vertices.clear();
		base_mesh.indices.clear();

		// Generate a mesh for each side.
		generate_side_mesh(true, false);
		generate_side_mesh(true, true);
		generate_side_mesh(false, false);
		generate_side_mesh(false, true);

		// Generate a mesh for the bottom.
		generate_bottom_mesh();
	}


	void generate_meshes()
	{
		center_matrix = glm::translate(glm::fvec3{-size.x/2.f, 0.f, -size.y/2.f});

		generate_dft_mesh();
		generate_base_mesh();
	}


	void nonnegative_validation(float x, const std::string& name)
	{
		if(x < 0) throw std::runtime_error{"The "+name+" value cannot be negative."};
	}


	void minmax_validation(float x, float minimum, float maximum, const std::string& name)
	{
		if(x <= minimum) throw std::runtime_error{
			"The "+name+" value must be above "+std::to_string(minimum)+"."};

		if(x > maximum) throw std::runtime_error{
			"The "+name+" value must be below "+std::to_string(maximum)+"."};
	}
}


void LV::Generator::configure(float dft_window_duration, float dft_sample_interval,
	float harmonic_smoothing, float temporal_smoothing, float height_multiplier,
	const std::string& logarithmic)
{
	std::cout<<"Configuring...\n";

	// Validate.
	if(logarithmic != "true" && logarithmic != "false") throw std::runtime_error{
		"The logarithmic value must be either \"true\" or \"false\"."};

	nonnegative_validation(dft_window_duration, "DFT window duration");
	nonnegative_validation(dft_sample_interval, "DFT sample interval");
	nonnegative_validation(temporal_smoothing, "temporal smoothing");
	nonnegative_validation(harmonic_smoothing, "harmonic smoothing");
	minmax_validation(height_multiplier, .1f, 10.f, "height multiplier");

	// Apply.
	::dft_window_duration = dft_window_duration;
	::dft_sample_interval = dft_sample_interval;
	::harmonic_smoothing = static_cast<int>(harmonic_smoothing);
	::temporal_smoothing = static_cast<int>(temporal_smoothing);
	::height_multiplier = height_multiplier;
	::logarithmic = logarithmic == "true" ? true : false;

	std::cout<<"Configured.\n";
}


void LV::Generator::generate(const std::string& file_name)
{
	// Load the audio data.
	load_audio_data(file_name);

	// Generate the DFT data.
	generate_dft_data();

	// Generate the meshes.
	generate_meshes();
}


glm::ivec2 LV::Generator::get_size(){ return size; }

float LV::Generator::get_height(){ return height; }

LV::Mesh LV::Generator::get_dft_mesh(){ return dft_mesh; }

LV::Mesh LV::Generator::get_base_mesh(){ return base_mesh; }
